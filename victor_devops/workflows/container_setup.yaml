# Container Setup Workflow
# ========================
# Docker/container setup and configuration with:
# - Requirements analysis
# - Dockerfile creation and optimization
# - Multi-stage builds
# - Security scanning
# - Registry push
#
# ┌─────────────────────────────────────────────────────────────────────────────┐
# │ EXECUTION ENVIRONMENT                                                        │
# ├─────────────────────────────────────────────────────────────────────────────┤
# │ Default: in-process (Python) + subprocess (Docker CLI)                      │
# │ Supported: in-process, subprocess, docker (yes, Docker-in-Docker)           │
# │                                                                              │
# │ Requirements:                                                                │
# │   - Docker Engine (or podman with docker alias)                             │
# │   - docker-compose / docker compose plugin                                  │
# │   - trivy for security scanning                                             │
# │   - Registry credentials for push                                           │
# │                                                                              │
# │ Docker-in-Docker (DinD):                                                    │
# │   - For CI pipelines: use dind sidecar or socket mount                      │
# │   - Security: Prefer rootless mode or kaniko for builds                     │
# │                                                                              │
# │ Network requirements:                                                        │
# │   - build_image: Local Docker socket only                                   │
# │   - security_scan: Downloads vulnerability DB (~500MB)                      │
# │   - push_image: Registry network access                                     │
# └─────────────────────────────────────────────────────────────────────────────┘
#
# ┌─────────────────────────────────────────────────────────────────────────────┐
# │ DEFAULT VALUES                                                               │
# ├─────────────────────────────────────────────────────────────────────────────┤
# │ image_tag: app:latest (or from git tag/branch)                              │
# │ max_size: 500 MB (warning threshold)                                        │
# │ health_endpoint: /health (or /_health, /healthz)                            │
# │ startup_timeout: 30s (container startup wait)                               │
# │ scanner: trivy (alternative: grype, clair)                                  │
# │ container_registry: docker.io (or ecr, gcr, ghcr)                          │
# │ hitl_timeout: 600s (10 min for approvals)                                   │
# └─────────────────────────────────────────────────────────────────────────────┘
#
# ┌─────────────────────────────────────────────────────────────────────────────┐
# │ COMPUTE vs AGENT NODE RATIONALE                                              │
# ├─────────────────────────────────────────────────────────────────────────────┤
# │ COMPUTE nodes (no LLM reasoning):                                            │
# │   - build_image: docker build subprocess (deterministic)                    │
# │   - security_scan: trivy scan subprocess (rule-based detection)             │
# │   - test_container: docker run + health checks (pass/fail)                  │
# │   - push_image: docker push subprocess (network I/O)                        │
# │   All are subprocess commands with structured output.                        │
# │                                                                              │
# │ AGENT nodes (require LLM reasoning):                                         │
# │   - analyze_requirements: DECIDING base image, dependencies                 │
# │   - create_dockerfile: WRITING Dockerfile with best practices               │
# │   - create_compose: WRITING docker-compose.yml                              │
# │   - fix_dockerfile: DEBUGGING and FIXING build errors                       │
# │   - investigate_failure: ANALYZING logs for root cause                      │
# │   All require interpretation, judgment, or creative writing.                │
# └─────────────────────────────────────────────────────────────────────────────┘

workflows:
  container_setup:
    description: "Container setup with Dockerfile creation and optimization"

    metadata:
      version: "1.0"
      author: "victor"
      vertical: devops

    # =========================================================================
    # SERVICE DEFINITIONS
    # =========================================================================
    services:
      # Docker socket access (passed through from host)
      docker:
        type: socket
        config:
          path: /var/run/docker.sock
        lifecycle:
          start: verify
          cleanup: none

    nodes:
      # =====================================================================
      # Stage 1: Requirements Analysis
      # =====================================================================
      - id: analyze_requirements
        type: agent
        name: "Analyze Container Requirements"
        role: analyst
        goal: |
          Analyze application requirements for containerization:

          1. **Application Analysis**
             - Detect language/runtime (Python, Node, Go, etc.)
             - Identify dependencies (package managers, libraries)
             - Find configuration files

          2. **Resource Requirements**
             - Estimate CPU/memory needs
             - Identify storage requirements
             - Note network dependencies

          3. **Environment Variables**
             - Find required env vars
             - Identify secrets management needs

          4. **Base Image Selection**
             - Recommend appropriate base image
             - Consider security vs. size trade-offs
        tool_budget: 20
        tools: [read, shell, grep]
        llm_config:
          temperature: 0.2
        input_mapping:
          app_path: application_path
        output: requirements
        next: [create_dockerfile]

      # =====================================================================
      # Stage 2: Dockerfile Creation
      # =====================================================================
      - id: create_dockerfile
        type: agent
        name: "Create Dockerfile"
        role: executor
        goal: |
          Create an optimized Dockerfile:

          **Best Practices:**
          1. Use specific base image tags (not :latest)
          2. Implement multi-stage builds for smaller images
          3. Order layers for optimal caching
          4. Minimize layer count
          5. Use .dockerignore

          **Security Considerations:**
          - Run as non-root user
          - Remove build dependencies
          - No secrets in image

          **Performance:**
          - Copy dependency files first
          - Install dependencies before code
          - Clean up apt/npm caches
        tool_budget: 25
        tools: [read, write]
        llm_config:
          temperature: 0.2
        input_mapping:
          reqs: requirements
          app_path: application_path
        output: dockerfile_path
        next: [create_compose]

      - id: create_compose
        type: agent
        name: "Create Docker Compose"
        role: executor
        goal: |
          Create docker-compose.yml for development:

          - Service definition
          - Volume mounts for live reload
          - Environment variables
          - Network configuration
          - Health checks
          - Depends_on for service ordering
        tool_budget: 15
        tools: [read, write]
        llm_config:
          temperature: 0.2
        input_mapping:
          dockerfile: dockerfile_path
          requirements: requirements
        output: compose_path
        next: [build_image]

      # =====================================================================
      # Stage 3: Build and Validate
      # =====================================================================
      # COMPUTE: docker build is subprocess with structured output
      # ─────────────────────────────────────────────────────────────────────
      # Algorithm: subprocess.run(["docker", "build", ...])
      # Output: image ID, build logs, layer cache info
      # Build is deterministic given Dockerfile + context (unless using :latest)
      #
      # Execution: subprocess (docker CLI)
      # BLOCKED: [llm] - needs write for image layers, network for base images
      - id: build_image
        type: compute
        name: "Build Container Image"
        handler: container_ops
        inputs:
          operation: build
          dockerfile: $ctx.dockerfile_path
          tag: $ctx.image_tag
          build_args: $ctx.build_args
        output: build_result
        constraints: [llm]
        timeout: 600
        next: [check_build]

      - id: check_build
        type: condition
        name: "Check Build Status"
        condition: "container_build_status"
        branches:
          "success": security_scan
          "warning": review_size
          "failed": fix_dockerfile
          "default": security_scan

      - id: fix_dockerfile
        type: agent
        name: "Fix Dockerfile Issues"
        role: executor
        goal: |
          Fix Dockerfile build errors:
          {build_error}

          Common fixes:
          - Missing dependencies
          - Wrong base image
          - Permission issues
          - Path errors
        tool_budget: 15
        tools: [read, edit]
        llm_config:
          temperature: 0.1
        input_mapping:
          error: build_result.error
        output: fixed_dockerfile
        next: [build_image]

      - id: review_size
        type: hitl
        name: "Review Image Size"
        hitl_type: approval
        prompt: |
          ## Image Size Warning

          The built image is larger than recommended.

          **Image Size:** {image_size} MB
          **Recommended Maximum:** {max_size} MB

          **Optimization Suggestions:**
          - Use multi-stage builds
          - Choose a smaller base image (alpine)
          - Remove unnecessary files
          - Combine RUN commands

          Proceed anyway?
        context_keys:
          - image_size
          - max_size
        timeout: 600
        fallback: continue
        next: [security_scan]

      # =====================================================================
      # Stage 4: Security Scan
      # =====================================================================
      # COMPUTE: trivy/grype are rule-based vulnerability scanners
      # ─────────────────────────────────────────────────────────────────────
      # Algorithm: Matches image layers against CVE database
      # Output: Structured JSON with CVE IDs, severity, fixed versions
      # Deterministic given image + vulnerability DB version.
      #
      # Execution: subprocess (trivy, grype)
      # BLOCKED: [llm, write] - needs network to download vulnerability DB
      - id: security_scan
        type: compute
        name: "Security Scan"
        tools: [shell]
        inputs:
          image: $ctx.image_tag
          scanner: trivy
        output: scan_results
        constraints: [llm, write]
        timeout: 300
        next: [check_security]

      - id: check_security
        type: condition
        name: "Check Security Results"
        condition: "security_scan_verdict"
        branches:
          "pass": test_container
          "warn": review_vulnerabilities
          "fail": block_push

      - id: review_vulnerabilities
        type: hitl
        name: "Review Vulnerabilities"
        hitl_type: review
        prompt: |
          ## Security Vulnerabilities Found

          **Critical:** {critical_count}
          **High:** {high_count}
          **Medium:** {medium_count}
          **Low:** {low_count}

          **Top Vulnerabilities:**
          {vulnerability_summary}

          Review and decide whether to proceed.
        context_keys:
          - critical_count
          - high_count
          - medium_count
          - low_count
          - vulnerability_summary
        timeout: 900
        fallback: abort
        next: [test_container]

      - id: block_push
        type: transform
        name: "Block Push"
        transform: |
          push_blocked = true
          block_reason = "Critical security vulnerabilities"

      # =====================================================================
      # Stage 5: Test Container
      # =====================================================================
      # COMPUTE: Container tests are subprocess with pass/fail output
      # ─────────────────────────────────────────────────────────────────────
      # Algorithm: docker run + HTTP health check + log parsing
      # Tests: container_starts (exit code), health_check (HTTP 200), logs_no_errors
      # All boolean outcomes - no interpretation needed.
      #
      # Execution: subprocess (docker run, curl)
      # BLOCKED: [llm] - needs network for health checks, write for containers
      - id: test_container
        type: compute
        name: "Test Container"
        handler: container_tester
        tools: [shell]
        inputs:
          image: $ctx.image_tag
          compose: $ctx.compose_path
          health_endpoint: $ctx.health_endpoint
          startup_timeout: 30
          tests:
            - container_starts
            - health_check_passes
            - logs_no_errors
          cleanup: true
        output: test_results
        constraints: [llm]
        timeout: 180
        next: [check_tests]

      - id: check_tests
        type: condition
        name: "Check Test Results"
        condition: "test_results.success"
        branches:
          "true": push_approval
          "false": investigate_failure
          "default": push_approval

      - id: investigate_failure
        type: agent
        name: "Investigate Test Failure"
        role: analyst
        goal: |
          Investigate why container tests failed:
          {test_error}

          Check:
          - Container logs
          - Startup sequence
          - Port bindings
          - Environment variables
        tool_budget: 15
        tools: [shell, read]
        llm_config:
          temperature: 0.2
        output: investigation
        next: [fix_dockerfile]

      # =====================================================================
      # Stage 6: Push to Registry
      # =====================================================================
      - id: push_approval
        type: hitl
        name: "Push Approval"
        hitl_type: approval
        prompt: |
          ## Ready to Push to Registry

          **Image:** {image_tag}
          **Size:** {image_size} MB
          **Security:** {security_status}
          **Tests:** Passed

          Push to registry?
        context_keys:
          - image_tag
          - image_size
          - security_status
        timeout: 600
        fallback: continue
        next: [push_image]

      # COMPUTE: docker push is subprocess with network I/O
      # ─────────────────────────────────────────────────────────────────────
      # Algorithm: docker push subprocess to registry
      # Output: Push logs, layer digests, final manifest digest
      #
      # Execution: subprocess (docker push)
      # BLOCKED: [llm, write] - needs network for registry push
      - id: push_image
        type: compute
        name: "Push to Registry"
        handler: container_ops
        inputs:
          operation: push
          tag: $ctx.image_tag
          registry: $ctx.container_registry
        output: push_result
        constraints: [llm, write]
        timeout: 300
        next: [complete]

      - id: complete
        type: transform
        name: "Container Setup Complete"
        transform: |
          workflow_status = "completed"
          outputs = {
            "dockerfile": dockerfile_path,
            "compose": compose_path,
            "image": image_tag,
            "pushed": push_result.success
          }


  # =========================================================================
  # Quick Container Build
  # =========================================================================
  # Fast-path workflow for quick iterations without security scan
  # Execution: in-process + subprocess (docker)
  container_quick:
    description: "Quick container build without security scan"

    metadata:
      vertical: devops

    nodes:
      # Agent node (type defaults to 'agent', so omitted)
      - id: quick_analyze
        name: "Quick Analysis"
        role: analyst
        goal: |
          Quickly analyze application and create Dockerfile.
          Focus on getting it working, optimize later.
        tool_budget: 15
        tools: [read, write]
        llm_config:
          temperature: 0.3
          model_hint: claude-3-sonnet
        output: dockerfile
        next: [quick_build]

      # COMPUTE: docker build subprocess
      # BLOCKED: [llm] - needs write/network for build
      - id: quick_build
        type: compute
        name: "Quick Build"
        handler: container_ops
        inputs:
          operation: build
          tag: $ctx.image_tag
        output: build_result
        constraints: [llm]
        timeout: 300
        next: [quick_test]

      # COMPUTE: docker run smoke test
      # BLOCKED: [llm] - simple pass/fail subprocess
      - id: quick_test
        type: compute
        name: "Quick Test"
        tools: [shell]
        inputs:
          command: "docker run --rm ${image_tag} echo 'Container works'"
        output: test_result
        constraints: [llm]
        timeout: 60
